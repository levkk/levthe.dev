<!DOCTYPE html>
<html lang="en">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Creating your own programming language is an exciting and eye-opening experience. As coders, we rarely if ever get a say in how our tools work. Languages like Python, Ruby, C/C&#43;&#43; and even Rust have been around for a while and are used by millions. Therefore, adding a feature we want or removing an annoyance is often a multi-year process that goes nowhere.
Designing your own language however, gives you the freedom to do whatever you want." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="http://localhost:1313/posts/language-interpreter-from-scratch-part-1/" />


    <title>
        
            Language interpreter from scratch in Rust: Part 1 of many :: Lev&#39;s blog 
        
    </title>





<link rel="stylesheet" href="/main.949191c1dcc9c4a887997048b240354e47152016d821198f89448496ba42e491.css" integrity="sha256-lJGRwdzJxKiHmXBIskA1TkcVIBbYIRmPiUSElrpC5JE=">



    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="">



  <meta itemprop="name" content="Language interpreter from scratch in Rust: Part 1 of many">
  <meta itemprop="description" content="Creating your own programming language is an exciting and eye-opening experience. As coders, we rarely if ever get a say in how our tools work. Languages like Python, Ruby, C/C&#43;&#43; and even Rust have been around for a while and are used by millions. Therefore, adding a feature we want or removing an annoyance is often a multi-year process that goes nowhere.
Designing your own language however, gives you the freedom to do whatever you want.">
  <meta itemprop="datePublished" content="2024-08-01T13:33:45-04:00">
  <meta itemprop="dateModified" content="2024-08-01T13:33:45-04:00">
  <meta itemprop="wordCount" content="5397">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Language interpreter from scratch in Rust: Part 1 of many">
  <meta name="twitter:description" content="Creating your own programming language is an exciting and eye-opening experience. As coders, we rarely if ever get a say in how our tools work. Languages like Python, Ruby, C/C&#43;&#43; and even Rust have been around for a while and are used by millions. Therefore, adding a feature we want or removing an annoyance is often a multi-year process that goes nowhere.
Designing your own language however, gives you the freedom to do whatever you want.">







    <meta property="article:published_time" content="2024-08-01 13:33:45 -0400 -0400" />











    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text ">
                Lev's blog</span>
            
        
    </div>
</a>


        <span class="header__right">
            
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        
        

        
      </p>
    </div>

    <article>
      <div class="post-info">
        <p>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8" y1="2" x2="8" y2="6"></line>
            <line x1="3" y1="10" x2="21" y2="10"></line>
          </svg>
          
            2024-08-01 10:33
          

           
            
          
        </p>
      </div>
      <h1 class="post-title">
        <a href="http://localhost:1313/posts/language-interpreter-from-scratch-part-1/">Language interpreter from scratch in Rust: Part 1 of many</a>
      </h1>

      

      

      

      <div class="post-content">
        <p>Creating your own programming language is an exciting and eye-opening experience. As coders, we rarely if ever get a say in how our tools work. Languages like Python, Ruby, C/C++ and even Rust have been around for a while and are used by millions. Therefore, adding a feature we want or removing an annoyance is often a multi-year process that goes nowhere.</p>
<p>Designing your own language however, gives you the freedom to do whatever you want. As you dive deeper into the implementation of your interpreter, you will get to make decisions that impact the users of your language, possibly for decades to come. If nothing else, you will build empathy with other compiler authors and become a more enlightened engineer.</p>
<p>This post is the first in a series that will guide you through designing your own programming language, and an interpreter program that will parse and execute your language.</p>
<h2 id="quick-introduction">Quick introduction</h2>
<p>All programming languages, from the friendliest ones like Python, to the incomprehensible ones like C++, are built using two independent components: a lexer and a parser. This design pattern has existed for as long as I have been studying computing, so I will take it for granted and use it in this guide.</p>
<p>Where our interpreter will diverge is, instead of compiling our language to assembly, like the C++ compiler would do, or to some custom intermediate &ldquo;bytecode&rdquo; like the Python interpreter does, we will execute code directly.</p>
<p>Our interpreter will be written in Rust, so we will not have to worry about memory management or performance (for now), and end up with something that is not just a toy example.</p>
<p>All code examples will also have a Rust Playground link, so you can run and edit them as you follow along.</p>
<p>Without further ado, let&rsquo;s get started.</p>
<h2 id="lexer">Lexer</h2>
<p>The lexer takes text and converts it to a list of tokens. A token could be a letter, a word, a number, or a punctuation mark. Tokens have meaning depending on their position in the code, but the lexer will not concern itself with syntax: its only job is to transform text into an allowed list of symbols.</p>
<h3 id="example">Example</h3>
<p>Most programming languages allow its users to do math. Let&rsquo;s start building our interpreter with a simple arithmetic example, and write a lexer that can handle it.</p>
<p><em>The code</em></p>
<pre tabindex="0"><code>1 + 2
</code></pre><p>The job of the lexer is to transform this code into the following tokens:</p>
<pre tabindex="0"><code>Number(1), Plus, Number(2)
</code></pre><p>While you probably think that this program will add one and two together and produce <code>3</code>, the lexer is not allowed to make assumptions about syntax or what the code will do.</p>
<p>Since we are writing our lexer in Rust, an enum that will represent all allowed tokens in our simple language seems like a good abstraction:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// List of all available tokens in our language.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Token</span> {
</span></span><span style="display:flex;"><span>    Number(<span style="color:#66d9ef">i64</span>),
</span></span><span style="display:flex;"><span>    Plus,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This list of tokens is short, but as our language evolves, it will get longer and more interesting. Our language can only add numbers at the moment, but we will add more features later, like control flow with <code>if</code> statements and <code>for</code> loops.</p>
<h3 id="extracting-tokens">Extracting tokens</h3>
<p>At the most basic level, a token is a single character, like the plus sign (<code>+</code>). Our lexer therefore will start processing the source code one character at a time:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Lexer</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Source code.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    source: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Resulting list of tokens.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    tokens: Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> Lexer<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(source: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>) -&gt; <span style="color:#a6e22e">Lexer</span> {
</span></span><span style="display:flex;"><span>        Lexer {
</span></span><span style="display:flex;"><span>            source,
</span></span><span style="display:flex;"><span>            tokens: Vec::new(),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Extract tokens one character at a time.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tokens</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> self.source.chars() {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Placeholder for actual lexer logic.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            todo!(<span style="color:#e6db74">&#34;extract tokens&#34;</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Return all tokens, leaving an empty list in their place.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// This allows to parse the same code multiple times
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// without creating a new lexer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std::mem::take(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self.tokens)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since our language only supports adding numbers, our tokens can only include numbers between <code>0</code> and <code>9</code>, and the <code>+</code> sign:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> self.source.chars() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> c {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Convert numbers between 0 and 9 to Rust integers.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">..=</span><span style="color:#e6db74">&#39;9&#39;</span> <span style="color:#f92672">=&gt;</span> self.tokens.push(
</span></span><span style="display:flex;"><span>            Token::Number(c.to_digit(<span style="color:#ae81ff">10</span>).unwrap() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i64</span>)
</span></span><span style="display:flex;"><span>        ),
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Convert the plus sign to the plus token.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">=&gt;</span> self.tokens.push(Token::Plus),
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Error out on unknown characters.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        c <span style="color:#f92672">=&gt;</span> todo!(<span style="color:#e6db74">&#34;lexer error, unsupported character: &#39;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#39;&#34;</span>, c),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>While short, this code does quite a bit: it extracts characters from text, maps them to the vocabulary of our language, and produces values that our interpreter can later understand. Since parsing text is handled by the lexer, the rest of our interpreter, namely the parser, can only work with a single enum. This separation of concerns makes compilers (and interpreters) easier to write and maintain.</p>
<h3 id="testing-the-lexer">Testing the lexer</h3>
<p>Before writing any more code, we should probably write a simple test to make sure we are on the right track. I am writing this in a Rust binary project, so we can just add this to the <code>main</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> source <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1 + 2&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lexer <span style="color:#f92672">=</span> Lexer::new(source);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, lexer.tokens());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This code compiles fine, so let&rsquo;s try it:</p>
<pre tabindex="0"><code>thread &#39;main&#39; panicked at src/main.rs:38:22:
not yet implemented: lexer error, unsupported character: &#39; &#39;
</code></pre><p>If you have done this before, you probably noticed this problem already, but for beginners this may come as a surprise: the space character (<code> </code>) is also a token which is part of the language. Therefore, the lexer needs to handle it. We do not have a use for the &ldquo;space&rdquo; token yet, so we will ignore it for now:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">match</span> c {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Ignore spaces.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">continue</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">..=</span><span style="color:#e6db74">&#39;9&#39;</span> <span style="color:#f92672">=&gt;</span> self.tokens.push(
</span></span><span style="display:flex;"><span>        Token::Number(c.to_digit(<span style="color:#ae81ff">10</span>).unwrap() <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">i64</span>)
</span></span><span style="display:flex;"><span>    ),
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">=&gt;</span> self.tokens.push(Token::Plus),
</span></span><span style="display:flex;"><span>    c <span style="color:#f92672">=&gt;</span> todo!(<span style="color:#e6db74">&#34;lexer error, unsupported character: &#39;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#39;&#34;</span>, c),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Running our lexer now with support for spaces, we are getting the right result:</p>
<pre tabindex="0"><code>[Number(1), Plus, Number(2)]
</code></pre><h3 id="multi-character-tokens">Multi-character tokens</h3>
<p>We are keeping our language simple for now so we can build the entire interpreter in one go, but before we continue to the parser, let&rsquo;s add support for multi-character numbers. Our language would be pretty silly if it could only count to 9.</p>
<p>Since our lexer reads the code one character at a time, and numbers can be infinitely long, we need to add a buffer to collect digits as we consume them:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Lexer</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    source: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>    tokens: Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Buffer for multi-character tokens.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buffer: String,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> Lexer<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Process a multi-character token stored in the buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process_token</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Empty buffer means there is nothing to do here.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> self.buffer.is_empty() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Use the standard library&#39;s [`str::parse`]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// to convert text to an integer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        self.tokens.push(
</span></span><span style="display:flex;"><span>            Token::Number(self.buffer.as_str().parse().unwrap())
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Clear the buffer for the next token.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        self.buffer.clear();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now that we handle multi-character numbers, the space character needs to be handled differently. Since space now separates tokens, instead of just ignoring it, we will process whatever is in the buffer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> c <span style="color:#66d9ef">in</span> self.source.chars() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> c {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Spaces separate tokens.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">=&gt;</span> self.process_token(),
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Buffer number characters
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// instead of parsing them individually.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">..=</span><span style="color:#e6db74">&#39;9&#39;</span> <span style="color:#f92672">=&gt;</span> self.buffer.push(c),
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Everything else remains the same.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">=&gt;</span> self.tokens.push(Token::Plus),
</span></span><span style="display:flex;"><span>        c <span style="color:#f92672">=&gt;</span> todo!(<span style="color:#e6db74">&#34;lexer error, unsupported character: &#39;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#39;&#34;</span>, c),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Don&#39;t forget to process whatever is in the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// at the end of the input:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>self.process_token();
</span></span></code></pre></div><p>Let&rsquo;s add a bigger number to our source code and try the lexer now with actual support for numbers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> source <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;21 + 2&#34;</span>;
</span></span></code></pre></div><p>which produces:</p>
<pre tabindex="0"><code>[Number(21), Plus, Number(2)]
</code></pre><p>This is good enough to handle our simple language. While we may be tempted to add more tokens like <code>if</code>, <code>for</code>, or <code>-</code> to support more features, let&rsquo;s save that for later. By building the entire interpreter first, using the right abstractions, we will be able to easily add language features later.</p>
<p>Lexer code is available <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=158b82429a9d1373db4ff54234790a01">here</a>.</p>
<h2 id="parser">Parser</h2>
<p>The parser takes a list (sometimes called a stream) of tokens and produces an Abstract Syntax Tree. The AST, for short, is a structural representation of the code: it organizes tokens in such a way that makes sense in the context of the language rules. Constructing the AST consequently validates that the code is syntactically correct. When writing code in languages like Rust or Python, syntax errors which we are all too familiar with, are typically thrown by the parser.</p>
<p>Before we can build our parser, we need to get a bit more involved in our language design. By understanding a bit of theory, we can build the right abstractions early on, and make our job easier later.</p>
<h3 id="formal-definition">Formal definition</h3>
<p>A formal definition is a blueprint of valid language syntax. Its only job is to ensure that tokens are presented in the correct order. It does not explain what those tokens mean or do; while the reader could infer that an <code>if</code> statement controls which part of the code is executed, the language designer could make that statement exit the program instead. Of course, that would be somewhat cruel, but the formal definition we are about to write really does not concern itself with how the interpreter chooses to execute the code.</p>
<p>With that somewhat disturbing knowledge hammered into our minds, let&rsquo;s write something:</p>
<pre tabindex="0"><code>language = expression
expression = term operation term | term
term = value
value = number
operation = &#39;+&#39;
</code></pre><p>Before trying to understand what this means, let&rsquo;s throw in some definitions:</p>
<table>
<thead>
<tr>
<th>Term</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Language</td>
<td>The programming language definition.</td>
</tr>
<tr>
<td>Expression</td>
<td>Some code which, when executed, produces a single value as a result.</td>
</tr>
<tr>
<td>Term</td>
<td>A value, either constant (e.g. <code>21</code>) or variable (<code>source</code>). More on variables later.</td>
</tr>
<tr>
<td>Operation</td>
<td>An action that combines two terms into one.</td>
</tr>
<tr>
<td><code>=</code></td>
<td>&ldquo;is a&rdquo;</td>
</tr>
<tr>
<td><code>|</code></td>
<td>&ldquo;or a&rdquo;</td>
</tr>
</tbody>
</table>
<p>Now that we understand the lexicon a bit better, let&rsquo;s read our language definition one line at a time. At the top, we have:</p>
<pre tabindex="0"><code>language = expression
</code></pre><p>Our entire language is one expression. Programs written in our language can effectively contain only one line of code. A bit boring, but we will expand this later quite easily.</p>
<p>Moving on to the next line:</p>
<pre tabindex="0"><code>expression = term operation term | term
</code></pre><p>An expression in our language is either a binary operation on two terms, or a single term. For example, our example <code>21 + 2</code> is an expression of two terms joined together with a binary operator: the term on the left, <code>21</code>, is joined using the addition operator (<code>+</code>) to the right term, <code>2</code>.</p>
<p>Alternatively, if we just typed <code>21</code> into our interpreter, by itself that expression would evaluate to <code>21</code>. It is not immediately obvious why we need single-term expressions, but they will become useful once we will build more complex expressions.</p>
<p>Moving on to the next line:</p>
<pre tabindex="0"><code>term = value
</code></pre><p>A term in our language is a value. This may seem redundant; why not just use <code>value</code> in the <code>expression</code> definition? Later on, we will be adding additional types of terms, like a <code>variable</code>, so it is a good idea to keep our language definition flexible.</p>
<p>Moving down to the next line, the <code>value</code> is expanded to a number:</p>
<pre tabindex="0"><code>value = number
</code></pre><p>Our simple language only allows numbers, but soon enough we will add strings, lists and hashes. We will be able to define operations between values of different types, e.g. addition between a list and a string, and our language will really take form.</p>
<p>Finally, our only operation, addition, is specified on the last line:</p>
<pre tabindex="0"><code>operation = &#39;+&#39;
</code></pre><h4 id="parsing-our-example">Parsing our example</h4>
<p>Now that we have formal definitions, let&rsquo;s parse our example manually. Our code,</p>
<pre tabindex="0"><code>1 + 2
</code></pre><p>based on our formal language definition, should produce the following AST:</p>
<p><img src="ast.png" alt="AST"></p>
<h3 id="parsing-expressions">Parsing expressions</h3>
<p>Now that we have a formal definition and an example of an AST, let&rsquo;s parse our example, starting at the bottom:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// An operation. Only addition currently supported.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Operation</span> {
</span></span><span style="display:flex;"><span>    Addition,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// A constant value. Currently, only numbers are supported.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Value</span> {
</span></span><span style="display:flex;"><span>    Number(<span style="color:#66d9ef">i64</span>),
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// Expression term. Currently, only values are supported.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Term</span> {
</span></span><span style="display:flex;"><span>    Value(Value),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With the basic building blocks of our language ready, let&rsquo;s define an expression. If we recall the formal definition, an expression can either be a binary operation between two terms, or a just a term:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Expression</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// A binary operation.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    Binary {
</span></span><span style="display:flex;"><span>        left: <span style="color:#a6e22e">Term</span>,
</span></span><span style="display:flex;"><span>        op: <span style="color:#a6e22e">Operation</span>,
</span></span><span style="display:flex;"><span>        right: <span style="color:#a6e22e">Term</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Just a term by itself.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    Term(Term),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>That&rsquo;s not a lot of code given our long theoretical explanation, but that was the goal: as we understood theory, implementing the parser becomes easy.</p>
<h3 id="parsing-tokens">Parsing tokens</h3>
<p>Just like the lexer, a parser processes tokens one at a time. Since our language only has expressions, to have a complete language parser, we just need to implement expression parsing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::iter::Iterator;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Expression {
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Given a stream of tokens, parse a single expression.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse</span>(
</span></span><span style="display:flex;"><span>        stream: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> <span style="color:#66d9ef">impl</span> Iterator<span style="color:#f92672">&lt;</span>Item <span style="color:#f92672">=</span> Token<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">Expression</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Parse the left term.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> left <span style="color:#f92672">=</span> Self::term(stream);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Optionally, parse the operator.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> operation <span style="color:#f92672">=</span> stream.next();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> operation {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// An operator is present, this is a binary operation.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Some(operation) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">let</span> op <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> operation {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// We only support addition. Throw a syntax error if
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">// we see anything else.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    Token::Plus <span style="color:#f92672">=&gt;</span> Operation::Addition,
</span></span><span style="display:flex;"><span>                    _ <span style="color:#f92672">=&gt;</span> panic!(
</span></span><span style="display:flex;"><span>                        <span style="color:#e6db74">&#34;syntax error, expected operation, got: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>,
</span></span><span style="display:flex;"><span>                        operation
</span></span><span style="display:flex;"><span>                    ),
</span></span><span style="display:flex;"><span>                };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// A binary operation must have two terms. Parse
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// the right term or throw an error if it&#39;s not there.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">let</span> right <span style="color:#f92672">=</span> Self::term(stream);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Expression::Binary {
</span></span><span style="display:flex;"><span>                    left,
</span></span><span style="display:flex;"><span>                    op,
</span></span><span style="display:flex;"><span>                    right,
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Expression has no operator, this is just a single term.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            None <span style="color:#f92672">=&gt;</span> Expression::Term(left),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Given a stream of tokens, parse a single term.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">term</span>(
</span></span><span style="display:flex;"><span>        stream: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> <span style="color:#66d9ef">impl</span> Iterator<span style="color:#f92672">&lt;</span>Item <span style="color:#f92672">=</span> Token<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">Term</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> token <span style="color:#f92672">=</span> stream.next().expect(<span style="color:#e6db74">&#34;expected a token&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> token {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Convert the number token to a term containing a value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// No other tokens are supported here, so throw
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// a syntax error if another token is there instead.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Token::Number(n) <span style="color:#f92672">=&gt;</span> Term::Value(Value::Number(n)),
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> panic!(<span style="color:#e6db74">&#34;syntax error, expected term, got: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, token),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="testing-the-parser">Testing the parser</h3>
<p>Since we have source code and a lexer already, we can add the parser to it pretty easily. Going back to our <code>main</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> source <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;21 + 2&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lexer <span style="color:#f92672">=</span> Lexer::new(source);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tokens <span style="color:#f92672">=</span> lexer.tokens();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> expression <span style="color:#f92672">=</span> Expression::parse(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> tokens.into_iter());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:#?}</span><span style="color:#e6db74">&#34;</span>, expression);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which produces:</p>
<pre tabindex="0"><code>Binary {
    left: Value(
        Number(
            21,
        ),
    ),
    op: Addition,
    right: Value(
        Number(
            2,
        ),
    ),
}
</code></pre><p>That looks about right. Let&rsquo;s recap. We have converted text into tokens, parsed those tokens with our own parser, created an Abstract Syntax Tree, and validated syntax using our formal language definition. That was a lot of work just to add two numbers together, but the payoff is finally here: let&rsquo;s bring our own interpreter to life by executing our AST.</p>
<p>Source code for the parser is <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=047a475186aa72ad5dd080dc00355a57">here</a>.</p>
<h2 id="executor">Executor</h2>
<p>An executor, unlike a compiler, takes the intermediary representation of the code (the AST) and executes it directly on the machine where the code is read. A compiler, on the other hand, translates the AST into machine code, or another language, which is then executed by either another interpreter or another machine.</p>
<p>For example, if you are familiar with TypeScript, the TypeScript compiler translates TypeScript code into JavaScript, which is then executed by the V8 interpreter. To make things even more interesting, V8 can also act as a compiler, by translating JavaScript into assembly and executing it directly on the CPU. This is called JIT (Just-in-Time) compilation, a topic we will explore at another time.</p>
<p>Since our language is written in Rust, our interpreter will be able to execute code on any machine where Rust is supported. This makes our language pretty flexible, since Rust can run on all Intel, AMD, and ARM CPUs, Linux, Windows and Mac. For example, another popular interpreted language, Python, is actually written in C, which makes it even more portable.</p>
<p>That is enough theory. Let&rsquo;s get to business of executing code.</p>
<h3 id="evaluating-expressions">Evaluating expressions</h3>
<p>Our expressions, currently, only have two variants: binary operation and a single term. Both need to have an execution path, so let&rsquo;s handle them both in one simple function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Expression {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Evaluate an expression and produce a single value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">evaluate</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">Value</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> self {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Single-term expressions just evaluate to the value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// they are holding.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Expression::Term(Term::Value(value)) <span style="color:#f92672">=&gt;</span> value.clone(),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Binary operations execute the operation.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Expression::Binary {
</span></span><span style="display:flex;"><span>                left: <span style="color:#a6e22e">Term</span>::Value(left),
</span></span><span style="display:flex;"><span>                op,
</span></span><span style="display:flex;"><span>                right: <span style="color:#a6e22e">Term</span>::Value(right)
</span></span><span style="display:flex;"><span>            } <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">match</span> op {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// Only addition is currently defined,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">// just add the two values together in Rust.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    Operation::Addition <span style="color:#f92672">=&gt;</span> left.clone() <span style="color:#f92672">+</span> right.clone(),
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Looking back at our formal definition, an expression is some code that, when executed, returns a single value. So, the <code>evaluate</code> method takes an expression, and has to return a <code>Value</code>. The first kind of expression, a single term, is easy to execute: it just returns whatever value it is holding.</p>
<p>The binary operation is only slightly more involved. To evaluate it, we take the left side and join it with the right side using the specified operation. Since we currently support only addition, the operation we are implementing is simple: we add the two values together.</p>
<p>Compiling this code, we get a couple errors:</p>
<pre tabindex="0"><code>value.clone(),
^^^^^^^^^^^^^ expected `Value`, found `&amp;Value

note: `Value` does not implement `Clone`, so `&amp;Value` was cloned instead
</code></pre><p>and</p>
<pre tabindex="0"><code>cannot add `Value` to `Value`

note: an implementation of `Add` might be missing for `Value`
</code></pre><p>The first one is easy to fix. Let&rsquo;s add a <code>Clone</code> implementation to our <code>Value</code> enum:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Value</span> {
</span></span><span style="display:flex;"><span>    Number(<span style="color:#66d9ef">i64</span>),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The second error asks us to explain to the Rust compiler how to add two <code>Value</code> enums together. The idiomatic way to do this in Rust is to implement the <code>std::ops::Add</code> trait, which we can do as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::ops::Add;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Add <span style="color:#66d9ef">for</span> Value {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add</span>(self, other: <span style="color:#a6e22e">Value</span>) -&gt; <span style="color:#a6e22e">Value</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> (self, other) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// A bit of basic math here.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            (Value::Number(a), Value::Number(b)) <span style="color:#f92672">=&gt;</span> Value::Number(a <span style="color:#f92672">+</span> b),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Going back to our <code>main</code> function, let&rsquo;s evaluate our example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> source <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;21 + 2&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Parse the code into tokens.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lexer <span style="color:#f92672">=</span> Lexer::new(source);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tokens <span style="color:#f92672">=</span> lexer.tokens();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Parse the tokens into an AST.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> expression <span style="color:#f92672">=</span> Expression::parse(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> tokens.into_iter());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Execute the AST producing a single value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> expression.evaluate();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, result);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Running our interpreter, we finally get:</p>
<pre tabindex="0"><code>Number(23)
</code></pre><p>That was quite a journey, but we are finally here. With only 175 lines of code, we managed to read text and add two numbers together. Talk about doing things the hard way, but it is definitely more fun and informative than just typing them into a Google search field.</p>
<p>Source code is available <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8c50fd21a8b49b92005addc503bf22e6">here</a>.</p>
<h2 id="quick-recap">Quick recap</h2>
<p>Before going further, let&rsquo;s do a quick recap.</p>
<p>First, we built a lexer, which takes text and converts it to a list of predefined tokens.  Second, we wrote a parser which takes that list and converts it to an Abstract Syntax Tree. The parser validates language syntax, and creates an intermediary representation of the source code.</p>
<p>Lastly, we wrote an executor that takes the AST and executes it to produce a single value. Our executor is written in Rust, so it can run our code on any machine supported by the Rust compiler.</p>
<p>This was great and all, but it is hard to see why this was necessary. Well, let&rsquo;s shake things up and add support for strings.</p>
<h2 id="adding-strings">Adding strings</h2>
<p>A string is a sequence of characters, which when interpreted, is represented as a value. For example, <code>&quot;hello world&quot;</code> is a string. How our language represents strings is completely up to us, and as the language designer you get to decide how you want this to work. For example, strings in C are placed between double quotes. Python, on the other hand, allows single, double, and even triple single or double quotes:</p>
<ul>
<li><code>'this is a string'</code></li>
<li><code>&quot;this is also a string&quot;</code></li>
<li><code>'''this is a multi-line string'''</code></li>
<li><code>&quot;&quot;&quot;this is also a multi-line string&quot;&quot;&quot;</code></li>
</ul>
<p>To support strings, we will need to make modifications at all three levels of our interpreter: we need to add support for parsing strings to the lexer, for representing strings in the AST in the parser, and finally executing operations on strings in the executor.</p>
<h3 id="lexer-1">Lexer</h3>
<p>The lexer gets to decide how strings are represented in code. Our lexer will follow the C string convention and only allow strings between double quotes. First, let&rsquo;s modify our lexicon to add a string token:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Token</span> {
</span></span><span style="display:flex;"><span>    Number(<span style="color:#66d9ef">i64</span>),
</span></span><span style="display:flex;"><span>    Plus,
</span></span><span style="display:flex;"><span>    String(String),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With that small modification out of the way, let&rsquo;s modify the lexer <code>tokens</code> method slightly to handle parsing strings:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> Lexer {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tokens</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Vec<span style="color:#f92672">&lt;</span>Token<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Create an iterator over the source code,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// one character at a time.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> chars <span style="color:#f92672">=</span> self.source.chars();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(c) <span style="color:#f92672">=</span> chars.next() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">match</span> c {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// No changes here.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">=&gt;</span> self.process_token(),
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">..=</span><span style="color:#e6db74">&#39;9&#39;</span> <span style="color:#f92672">=&gt;</span> self.buffer.push(c),
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;+&#39;</span> <span style="color:#f92672">=&gt;</span> self.tokens.push(Token::Plus),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Double quote indicating the start of a string.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#e6db74">&#39;&#34;&#39;</span> <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// Buffer a string into its own buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> string <span style="color:#f92672">=</span> String::new();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// Consume from the same iterator,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">// moving the lexer forward in the text stream.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(c) <span style="color:#f92672">=</span> chars.next() {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">match</span> c {
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e">// Closing double quote ends the string.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                            <span style="color:#e6db74">&#39;&#34;&#39;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">break</span>,
</span></span><span style="display:flex;"><span>                            _ <span style="color:#f92672">=&gt;</span> string.push(c),
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// We have a complete string.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    self.tokens.push(Token::String(string));
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                c <span style="color:#f92672">=&gt;</span> todo!(<span style="color:#e6db74">&#34;lexer error, unsupported character: &#39;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#39;&#34;</span>, c),
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Don&#39;t forget to process whatever is in the buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        self.process_token();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Return the list of tokens, emptying the lexer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std::mem::take(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self.tokens)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Looks good enough for now. Parsing strings can get more interesting, if you want to support escaping special characters (e.g. <code>\n</code>, the new line character) but for now, let&rsquo;s just test what we have. I am temporarily removing code that parses and evaluates this expression, since we have not added support for strings into the parser yet:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> source <span style="color:#f92672">=</span> <span style="color:#e6db74">r</span><span style="color:#e6db74">#&#34;21 + &#34;hello world&#34; + 2&#34;#</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Parse the code into tokens.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lexer <span style="color:#f92672">=</span> Lexer::new(source);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tokens <span style="color:#f92672">=</span> lexer.tokens();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, tokens);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which produces:</p>
<pre tabindex="0"><code>[Number(21), Plus, String(&#34;hello world&#34;), Plus, Number(2)]
</code></pre><p>While this may not make much sense yet in the context of our language, the lexer does not care and produces a valid list of tokens. Things are good, let&rsquo;s add strings into our Abstract Syntax Tree.</p>
<h3 id="parser-1">Parser</h3>
<p>The parser operates with values, so we need to add a string value to our <code>Value</code> enum first:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Value</span> {
</span></span><span style="display:flex;"><span>    Number(<span style="color:#66d9ef">i64</span>),
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// A value storing a string.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    String(String),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Compiling this will quickly produce an error since the <code>Value</code> enum is used inside the <code>std::ops::Add</code> trait implementation. Let&rsquo;s add a <code>todo</code> there for now, we are not sure yet what operations we want to support on strings:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Add <span style="color:#66d9ef">for</span> Value {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add</span>(self, other: <span style="color:#a6e22e">Value</span>) -&gt; <span style="color:#a6e22e">Value</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> (self, other) {
</span></span><span style="display:flex;"><span>            (Value::Number(a), Value::Number(b)) <span style="color:#f92672">=&gt;</span> Value::Number(a <span style="color:#f92672">+</span> b),
</span></span><span style="display:flex;"><span>            (a, b) <span style="color:#f92672">=&gt;</span> todo!(
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;syntax error, &#39;+&#39; between </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> and </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> not supported&#34;</span>,
</span></span><span style="display:flex;"><span>                a, b
</span></span><span style="display:flex;"><span>            ),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which now compiles, but if you attempt to parse this expression, you will still get a syntax error. Let&rsquo;s continue modifying the parser, and add support for parsing the <code>Token::String</code> token. <code>&quot;hello world&quot;</code> is a term, just like a number, so modifying term parsing should do the trick:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Expression {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// .. redacted for brevity
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">term</span>(stream: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> <span style="color:#66d9ef">impl</span> Iterator<span style="color:#f92672">&lt;</span>Item <span style="color:#f92672">=</span> Token<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Term</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> token <span style="color:#f92672">=</span> stream.next().expect(<span style="color:#e6db74">&#34;expected a token&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> token {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Number handling remains the same.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Token::Number(n) <span style="color:#f92672">=&gt;</span> Term::Value(Value::Number(n)),
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Handle the new string token.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            Token::String(s) <span style="color:#f92672">=&gt;</span> Term::Value(Value::String(s)),
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Still throw a syntax error on any other token.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            _ <span style="color:#f92672">=&gt;</span> panic!(<span style="color:#e6db74">&#34;syntax error, expected term, got: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, token),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Adding back parsing to <code>main</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> source <span style="color:#f92672">=</span> <span style="color:#e6db74">r</span><span style="color:#e6db74">#&#34;21 + &#34;hello world&#34;&#34;#</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Parse the code into tokens.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lexer <span style="color:#f92672">=</span> Lexer::new(source);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tokens <span style="color:#f92672">=</span> lexer.tokens();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Parse the tokens into an AST.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> expression <span style="color:#f92672">=</span> Expression::parse(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> tokens.into_iter());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:#?}</span><span style="color:#e6db74">&#34;</span>, expression);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Execute the AST producing a single value.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> expression.evaluate();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, result);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>we get:</p>
<pre tabindex="0"><code>Binary {
    left: Value(
        Number(
            21,
        ),
    ),
    op: Addition,
    right: Value(
        String(
            &#34;hello world&#34;,
        ),
    ),
}

thread &#39;main&#39; panicked at src/main.rs:101:23:

not yet implemented:

syntax error, addition between Number(21)
and String(&#34;hello world&#34;) not supported
</code></pre><p>Very cool, our parser can now build Abstract Syntax Trees which contain strings. You will note I removed the leftmost term (<code>+ 2</code>) from the expression. Our parser can only handle expressions with two terms for now. We will add support for unlimited terms later on, and that is when all these abstractions will really become worthwhile.</p>
<p>That being said, our interpreter is still not working. This is expected; we have not added support for string-based operations yet. Our language now can become unique and interesting.</p>
<h3 id="syntactic-sugar">Syntactic sugar</h3>
<p>Open up a Python interpreter and try running our code as is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ae81ff">21</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;hello world&#34;</span>
</span></span></code></pre></div><p>You will get this error:</p>
<pre tabindex="0"><code>TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;
</code></pre><p>That makes sense for Python, but what if we wanted to support this operation in our language, and if so, what would we make it do? Instead of throwing a syntax error, we could just convert the number to a string and concatenate the two together. Python forces you to write this out explicitly, e.g. <code>str(21) + &quot;hello world&quot;</code>, but we could do this automatically.</p>
<p>Doing an operation automatically because it is the most common and desired outcome is called &ldquo;syntactic sugar&rdquo;. The language designer makes it easy for language users to write code by executing some implied operations automatically. Going back to Python, if you run:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p>you will get a valid result:</p>
<pre tabindex="0"><code>&#34;hellohellohello&#34;
</code></pre><p>So the syntactic sugar for string multiplication by a number is available. We will add this to our language as well, but let&rsquo;s start with the basics first.</p>
<p>Going back to our syntax error, let&rsquo;s add support for string and number concatenation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Add <span style="color:#66d9ef">for</span> Value {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">add</span>(self, other: <span style="color:#a6e22e">Value</span>) -&gt; <span style="color:#a6e22e">Value</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> (self, other) {
</span></span><span style="display:flex;"><span>            (Value::Number(a), Value::Number(b)) <span style="color:#f92672">=&gt;</span> Value::Number(a <span style="color:#f92672">+</span> b),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Supports 21 + &#34;hello world&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            (
</span></span><span style="display:flex;"><span>                Value::Number(a),
</span></span><span style="display:flex;"><span>                Value::String(s),
</span></span><span style="display:flex;"><span>            ) <span style="color:#f92672">=&gt;</span> Value::String(a.to_string() <span style="color:#f92672">+</span> <span style="color:#f92672">&amp;</span>s),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Supports &#34;hello world&#34; + 21
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            (
</span></span><span style="display:flex;"><span>                Value::String(s),
</span></span><span style="display:flex;"><span>                Value::Number(a),
</span></span><span style="display:flex;"><span>            ) <span style="color:#f92672">=&gt;</span> Value::String(s <span style="color:#f92672">+</span> a.to_string().as_str()),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            (a, b) <span style="color:#f92672">=&gt;</span> todo!(
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;syntax error, &#39;+&#39; between </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> and </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> not supported&#34;</span>,
</span></span><span style="display:flex;"><span>                a, b
</span></span><span style="display:flex;"><span>            ),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Running our interpreter now, we get:</p>
<pre tabindex="0"><code>String(&#34;21hello world&#34;)
</code></pre><p>Now we are cooking with gas! Our language has a feature some other language does not, and we have implemented it from scratch in Rust. Last but not least, let&rsquo;s update our language formal definition to include the change we just made:</p>
<pre tabindex="0"><code>value = number | string
</code></pre><p>Source code available <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b2cf0b7d4b5d72dc060f096404014753">here</a>.</p>
<h3 id="adding-more-operations">Adding more operations</h3>
<p>Popular programming languages support a lot of operations and operators. To name a few:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Operator</th>
<th>Example</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>Addition</td>
<td><code>+</code></td>
<td><code>21 + 2</code></td>
<td><code>23</code></td>
</tr>
<tr>
<td>Subtraction</td>
<td><code>-</code></td>
<td><code>21 - 2</code></td>
<td><code>19</code></td>
</tr>
<tr>
<td>Multiplication</td>
<td><code>*</code></td>
<td><code>21 * 2</code></td>
<td><code>42</code></td>
</tr>
<tr>
<td>Division</td>
<td><code>/</code></td>
<td><code>21 / 2</code></td>
<td><code>10.5</code></td>
</tr>
<tr>
<td>Modulo</td>
<td><code>%</code></td>
<td><code>21 % 2</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td>Exponentiation</td>
<td><code>**</code></td>
<td><code>21 ** 2</code></td>
<td><code>441</code></td>
</tr>
</tbody>
</table>
<p>How our language handles those operations can make it unique and useful to its users. For example, in C, a division of two integers always produces an integer. If the division is not whole, e.g. <code>21 / 2</code>, the result is rounded towards zero, producing <code>10</code>. Meanwhile, in science-oriented languages like Python, the same division produces a floating point number, <code>10.5</code>.</p>
<p>This is not an accident and was done by design to make languages more useful inline with their indented audiences. Your language, depending on where you would want it to be used, can behave differently.</p>
<p>Let&rsquo;s add multiplication to our language. Following the same pattern as addition, we need to modify our lexer, parser and executor.</p>
<h4 id="add-token-to-lexer">Add token to lexer</h4>
<p>First thing we need to do is choose the token we want to signify multiplication. Since this is our language, we can use anything we want, e.g. <code>mul</code> or <code>x</code>, but to make our language easier to learn, we should probably just stick to the commonly used <code>*</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Token</span> {
</span></span><span style="display:flex;"><span>    Number(<span style="color:#66d9ef">i64</span>),
</span></span><span style="display:flex;"><span>    Plus,
</span></span><span style="display:flex;"><span>    String(String),
</span></span><span style="display:flex;"><span>    Star,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note the name of the token in the lexer is not tied to multiplication. In fact, we can use the Star token in other contexts, e.g. dereferencing pointers.</p>
<p>Going back to the <code>Lexer::tokens</code> function, parsing the Star token needs to be handled:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">match</span> c {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// .. redacted for brevity
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#f92672">=&gt;</span> self.tokens.push(Token::Star),
</span></span><span style="display:flex;"><span>    c <span style="color:#f92672">=&gt;</span> todo!(<span style="color:#e6db74">&#34;lexer error, unsupported character: &#39;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#39;&#34;</span>, c),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You can probably see already that as we add more tokens, this <code>match</code> statement will get quite large; while some programming books would encourage you to make your functions small, when programming parsers, you are better off keeping everything in one place, so you can easily add more tokens later.</p>
<h4 id="add-multiplication-to-parser">Add multiplication to parser</h4>
<p>At the parser, we get to decide what the Star token actually does, and since we are implementing multiplication, let&rsquo;s add it to the list of operations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Operation</span> {
</span></span><span style="display:flex;"><span>    Addition,
</span></span><span style="display:flex;"><span>    Multiplication,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Mapping the Star token in <code>Expression::parse</code> to multiplication, we get:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> op <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> operation {
</span></span><span style="display:flex;"><span>    Token::Plus <span style="color:#f92672">=&gt;</span> Operation::Addition,
</span></span><span style="display:flex;"><span>    Token::Star <span style="color:#f92672">=&gt;</span> Operation::Multiplication,
</span></span><span style="display:flex;"><span>    _ <span style="color:#f92672">=&gt;</span> panic!(<span style="color:#e6db74">&#34;syntax error, expected operation, got: </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, operation),
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Adding support for the actual operation to the executor in <code>Expression::evaluate</code>, we get:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">match</span> op {
</span></span><span style="display:flex;"><span>    Operation::Addition <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>        left.clone() <span style="color:#f92672">+</span> right.clone()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    Operation::Multiplication <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>        left.clone() <span style="color:#f92672">*</span> right.clone()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Just like with addition, we need to explain to Rust how to multiply two <code>Value</code> enums together. Idiomatically, we chose to implement the <code>std::ops::Mul</code> trait:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::ops::Mul;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Mul <span style="color:#66d9ef">for</span> Value {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">mul</span>(self, other: <span style="color:#a6e22e">Value</span>) -&gt; <span style="color:#a6e22e">Value</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> (self, other) {
</span></span><span style="display:flex;"><span>            (Value::Number(a), Value::Number(b)) <span style="color:#f92672">=&gt;</span> Value::Number(a <span style="color:#f92672">*</span> b),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Supports 3 * &#34;hello&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            (
</span></span><span style="display:flex;"><span>                Value::Number(a),
</span></span><span style="display:flex;"><span>                Value::String(s),
</span></span><span style="display:flex;"><span>            ) <span style="color:#f92672">=&gt;</span> Value::String(s.repeat(a <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>)),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Supports &#34;hello&#34; * 3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            (
</span></span><span style="display:flex;"><span>                Value::String(s),
</span></span><span style="display:flex;"><span>                Value::Number(a),
</span></span><span style="display:flex;"><span>            ) <span style="color:#f92672">=&gt;</span> Value::String(s.repeat(a <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>)),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            (a, b) <span style="color:#f92672">=&gt;</span> todo!(
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;syntax error, &#39;+&#39; between </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> and </span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74"> not supported&#34;</span>,
</span></span><span style="display:flex;"><span>                a, b
</span></span><span style="display:flex;"><span>            ),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If we change our source code in <code>main</code> to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> source <span style="color:#f92672">=</span> <span style="color:#e6db74">r</span><span style="color:#e6db74">#&#34;3 * &#34;hello&#34;&#34;#</span>;
</span></span></code></pre></div><p>our interpreter will produce</p>
<pre tabindex="0"><code>String(&#34;hellohellohello&#34;)
</code></pre><p>Our language is getting more powerful with each operation we add. More importantly, we showed that adding additional operations is a mechanical task:</p>
<ol>
<li>Pick a token and add it to the lexer</li>
<li>Map token to an operation in the parser</li>
<li>Add operation to executor</li>
</ol>
<p>The lexer, parser and executor abstractions are working well. Lastly, let&rsquo;s keep our language definition up to date:</p>
<pre tabindex="0"><code>operation = &#39;+&#39; | &#39;*&#39;
</code></pre><p>Full code is available <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=383394227bd99876688d7956f669829e">here</a>.</p>
<h2 id="summary">Summary</h2>
<p>In this post, we learned quite a few things. I would love to keep going, but almost 5,000 words is a good place to take a breather, so let&rsquo;s do a quick recap.</p>
<p>Programming languages are arbitrary, and you can design your own in about an hour. Writing the foundation for your interpreter requires less than 200 lines of code (most of which are comments).</p>
<p>The interpreter is split into three distinct parts, lexer, parser, and executor, working independently and together to run your code on many different systems. Separating concerns into their own abstractions seemed excessive at first, but as the language evolved, adding features was easy, and our interpreter was able to grow with the language.</p>
<p>We were able to build features into our language that another language chose not to support, making our language unique and useful for our purpose.</p>
<h2 id="next-steps">Next steps</h2>
<p>This is only the first part of many tutorials. Next ones will cover:</p>
<ul>
<li>Variables and scope</li>
<li>If statements, for loops</li>
<li>Functions</li>
<li>More syntactic sugar to make your language unique and useful</li>
</ul>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>I learned how to do this over the last couple of weeks from other great tutorials. One of my favorites is <a href="https://norasandler.com/2017/11/29/Write-a-Compiler.html">Writing a C Compiler</a> by Nora Sandler.</p>
<p>My motivation for writing this was to document my learning journey into writing an HTML template engine for a Rust web framework I am building. My hope is that others will find this useful. Feedback and corrections always welcome, please feel free to reach out at <a href="mailto:hi@levthe.dev">hi@levthe.dev</a>.</p>

      </div>
    </article>

    

    <div class="post-info">
      
      

      <p>
        
        
      </p>
    </div>

    
    <div class="pagination">
        

        <div class="pagination__buttons">
            

            
            <span class="button next">
                <a href="http://localhost:1313/posts/my-first-post/">
                    <span class="button__text">My first post</span>
                    <span class="button__icon">→</span>
                </a>
            </span>
            
        </div>
    </div>


    

    

    

  </main>

            </div>

            
                <footer class="footer">
    
    
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js" integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc&#43;cxaJzDdCYbAW0X1G&#43;DgZYvtKFXe6MBex8jUJ2JT25mQx&#43;YjACIng=="></script>




    </body>
</html>
