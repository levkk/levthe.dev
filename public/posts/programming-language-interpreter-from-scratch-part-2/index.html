<!DOCTYPE html>
<html lang="en">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="In our last post, we covered foundational topics like the lexer, parser, and interpreting expressions. Let&amp;rsquo;s keep going and learn a few more tricks that will make our programming language more useful.
Variables Variables are placeholders for values. Most languages expect them to hold a value at all times, although langauges like C allow them to be null (i.e. empty). Variables can be of different data types, and can be accessible from different levels in the code." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="http://localhost:1313/posts/programming-language-interpreter-from-scratch-part-2/" />


    <title>
        
            Programming language interpreter from scratch in Rust: Part 2 :: Lev&#39;s blog 
        
    </title>





<link rel="stylesheet" href="/main.31e2f0b046e806543185805ca954e4e9cd911f3da0b174a54babef6969e73da8.css" integrity="sha256-MeLwsEboBlQxhYBcqVTk6c2RHz2gsXSlS6vvaWnnPag=">



    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="">



  <meta itemprop="name" content="Programming language interpreter from scratch in Rust: Part 2">
  <meta itemprop="description" content="In our last post, we covered foundational topics like the lexer, parser, and interpreting expressions. Let’s keep going and learn a few more tricks that will make our programming language more useful.
Variables Variables are placeholders for values. Most languages expect them to hold a value at all times, although langauges like C allow them to be null (i.e. empty). Variables can be of different data types, and can be accessible from different levels in the code.">
  <meta itemprop="datePublished" content="2024-08-08T15:00:00-07:00">
  <meta itemprop="dateModified" content="2024-08-08T15:00:00-07:00">
  <meta itemprop="wordCount" content="509">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Programming language interpreter from scratch in Rust: Part 2">
  <meta name="twitter:description" content="In our last post, we covered foundational topics like the lexer, parser, and interpreting expressions. Let’s keep going and learn a few more tricks that will make our programming language more useful.
Variables Variables are placeholders for values. Most languages expect them to hold a value at all times, although langauges like C allow them to be null (i.e. empty). Variables can be of different data types, and can be accessible from different levels in the code.">







    <meta property="article:published_time" content="2024-08-08 15:00:00 -0700 PDT" />











    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text ">
                Lev's blog</span>
            
        
    </div>
</a>


        <span class="header__right">
            
        </span>
    </span>
</header>


            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        
        

        
      </p>
    </div>

    <article>
      <div class="post-info">
        <p>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8" y1="2" x2="8" y2="6"></line>
            <line x1="3" y1="10" x2="21" y2="10"></line>
          </svg>
          
            2024-08-08 15:00
          

           
            
          
        </p>
      </div>
      <h1 class="post-title">
        <a href="http://localhost:1313/posts/programming-language-interpreter-from-scratch-part-2/">Programming language interpreter from scratch in Rust: Part 2</a>
      </h1>

      

      

      

      <div class="post-content">
        <p>In our <a href="/posts/programming-language-interpreter-from-scratch-part-1">last post</a>, we covered foundational topics like the lexer, parser, and interpreting expressions. Let&rsquo;s keep going and learn a few more tricks that will make our programming language more useful.</p>
<h2 id="variables">Variables</h2>
<p>Variables are placeholders for values. Most languages expect them to hold a value at all times, although langauges like C allow them to be null (i.e. empty). Variables can be of different data types, and can be accessible from different levels in the code. Our language currently only allows a single expression, so adding variables will not require much planning.</p>
<p>Let&rsquo;s proceed in the same order as before, starting at the lexer.</p>
<h3 id="lexer">Lexer</h3>
<p>A variable is name. When we assign values to variables, e.g. <code>x = 5</code>, we are saying that a variable <em>named</em> <code>x</code> holds the value <code>5</code>. In programming language terms, a name is an identifier, i.e. an entity that refers to something else.</p>
<p>To represent this in the lexer, we need to add another token:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Token</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Tokens defined in our last post.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Number(<span style="color:#66d9ef">i64</span>),
</span></span><span style="display:flex;"><span>    Plus,
</span></span><span style="display:flex;"><span>    String(String),
</span></span><span style="display:flex;"><span>    Star,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The new identifier token.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Identifier(String),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When parsing code, an identifier is a token which is not some other token previously defined. For example, when parsing <code>21 + 2</code>, all tokens are already spoken for (i.e. <code>Number, Plus, Number</code>, spaces are ignored) however, if the code is changed to <code>21 + x</code>, the <code>x</code> token is not part of our grammar, and  therefore it must be an identity.</p>
<p>Implementing this in the parser requires a two small modifications. First, when parsing source code one at a time, instead of throwing an error when we encounter an unknown character, place it in the buffer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">match</span> c {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... redacted for brievity
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#f92672">=&gt;</span> self.tokens.push(Token::Star),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// All unknown characters are buffered
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// until a known token is seen.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    c <span style="color:#f92672">=&gt;</span> self.buffer.push(c),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Second, instead of treating all buffered tokens as numbers, we need to check if they are in fact identifiers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> Lexer<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process_token</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Empty buffer means there is nothing to do here.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> self.buffer.is_empty() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// If the token is numeric, parse it as a number.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(number) <span style="color:#f92672">=</span> self.buffer.as_str().parse() {
</span></span><span style="display:flex;"><span>            self.tokens.push(Token::Number(number));
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Otherwise, the token is some sort of word,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// which makes it an identifier.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            self.tokens.push(Token::Identifier(self.buffer.clone()));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        self.buffer.clear();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Testing the lexer against <code>21 + x</code>, like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> source <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;21 + x&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> lexer <span style="color:#f92672">=</span> Lexer::new(source);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, lexer.tokens());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Running our example, we now get:</p>
<pre tabindex="0"><code>[Number(21), Plus, Identifier(&#34;x&#34;)]
</code></pre><p>Everything looks good. Naming things is hard, and some languages do not make it easier. For examples, in C/C++, variables cannot start with a number, e.g. variable named <code>123x</code> would throw a syntax error. The reasons for this are not entirely clear (<a href="https://stackoverflow.com/questions/342152/why-cant-variable-names-start-with-numbers">1</a>), but if we had to take a guess, parsing every identifier is inefficient and slows down compilation. We will not concern ourselves with that for now and allow our language users to name their variables almost whatever they want.</p>
<h3 id="parser">Parser</h3>
<p>sdfs</p>

      </div>
    </article>

    

    <div class="post-info">
      
      

      <p>
        
        
      </p>
    </div>

    
    <div class="pagination">
        

        <div class="pagination__buttons">
            

            
            <span class="button next">
                <a href="http://localhost:1313/posts/programming-language-interpreter-from-scratch-part-1/">
                    <span class="button__text">Programming language interpreter from scratch in Rust: Part 1</span>
                    <span class="button__icon">→</span>
                </a>
            </span>
            
        </div>
    </div>


    

    

    

  </main>

            </div>

            
                <footer class="footer">
    
    
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js" integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc&#43;cxaJzDdCYbAW0X1G&#43;DgZYvtKFXe6MBex8jUJ2JT25mQx&#43;YjACIng=="></script>




    </body>
</html>
